# 第 4 章：数据治理神器：Pandas 的全流程攻略

在 NumPy 中，我们处理的是纯数字矩阵。但在现实世界里，数据是复杂的：

* **不仅有数字**，还有文本（商品名）、时间（下单时间）、布尔值（是否VIP）。
* **不仅有行和列**，还有“索引”（Index）和“列名”（Column Name）。
* **不仅有数据**，还有让人头疼的“缺失值”（NaN）。

**Pandas** 就是为了解决这些问题而生的。它基于 NumPy 构建，但提供了像 Excel 甚至 SQL 一样强大的数据操作能力。

---

## 4.1 核心架构：解剖 Pandas 的两大心脏

Pandas 的世界里只有两个主角。理解了它们，剩下的只是查文档而已。

### 1. Series (序列) —— 一维数据

* **形象理解:** Excel 表格中的**某一列**。
* **结构:** 它由两部分组成：**索引 (Index)** + **数据 (Data)**。
* **代码:** `df['价格']` 取出来的就是 Series。

### 2. DataFrame (数据框) —— 二维数据

* **形象理解:** 整个 Excel **表格**。
* **结构:** 它是多个 Series 拼合而成的。它有**行索引 (Index)** 和 **列名 (Columns)**。

---

## 4.2 从零开始：创建与读取

我们先在代码中凭空创造一个表格，感受一下它的结构。

```python
import pandas as pd
import numpy as np

# 1. 构造一个字典 (Key是列名, Value是数据列表)
data = {
    '日期': ['2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04', '2023-01-05'],
    '城市': ['北京', '上海', '广州', '北京', '深圳'],
    '温度': [100, 105, 120, 95, 110], # 假设单位是华氏度
    '风力': [3, 4, 2, 5, np.nan]     # np.nan 模拟数据丢失
}

# 2. 转换为 DataFrame
df = pd.DataFrame(data)

# 3. 设置索引 (Index)
# 默认索引是 0,1,2...，我们可以把“日期”设为索引，这样更符合直觉
df.set_index('日期', inplace=True)

print(df)

```

**运行结果模拟:**

```text
             城市   温度   风力
日期                            
2023-01-01   北京   100   3.0
2023-01-02   上海   105   4.0
2023-01-03   广州   120   2.0
2023-01-04   北京    95   5.0
2023-01-05   深圳   110   NaN  <-- 注意这个空值

```

> **🛠️ 常用读取指令:**
> * `pd.read_csv('file.csv')`: 读取逗号分隔文件 (最常用)。
> * `pd.read_excel('file.xlsx')`: 读取 Excel 文件 (需要安装 `openpyxl` 库)。
> * `pd.read_sql(...)`: 直接连接数据库读取。
> 
> 

---

## 4.3 数据的“全身体检”：查看与统计

拿到数据后，千万不要直接开始分析。先用以下命令给数据做个“体检”。

### 1. 宏观概览

* `df.head()`: 看前 5 行。确认数据读进来了，列名没乱码。
* `df.tail()`: 看最后 5 行。
* `df.shape`: **(重要)** 返回 `(行数, 列数)`。比如 `(1000, 20)` 代表有 1000 个样本，20 个特征。

### 2. 深度体检 (`info` & `describe`)

这是两个价值千金的函数。

```python
# 1. 查病历 (Info)
# 它可以告诉你：每一列是什么类型？有没有空值？
df.info()
# 关键看点：
# - Non-Null Count: 如果某列只有 800 non-null (总共1000行)，说明缺了 200 个。
# - Dtype: object 代表文本，int/float 代表数字。如果“价格”是 object，说明里面混入了字符。

# 2. 查指标 (Describe)
# 它可以一键算出：均值、标准差、最小值、25%/50%/75% 分位数、最大值。
df.describe()

```

---

## 4.4 数据的“手术刀”：索引与切片 (核心难点)

这是 Pandas 劝退新手的最大门槛：**`loc` 和 `iloc` 到底怎么分？**

我们用一张图来彻底搞懂它。

### 1. `loc` (Label Location): **“按名字找”**

* **规则:** 你眼睛看到的索引叫什么，就传什么。
* **语法:** `df.loc[行标签, 列标签]`
* **特点:** **“所见即所得”**，而且切片是**包含末尾**的。

```python
# 场景: 我想找 "2023-01-02" 这一天的 "城市" 和 "温度"
print(df.loc['2023-01-02', ['城市', '温度']])

# 场景: 我想找从 "1月1日" 到 "1月3日" 的所有数据 (注意：包含1月3日！)
print(df.loc['2023-01-01':'2023-01-03']) 

```

### 2. `iloc` (Integer Location): **“按位置找”**

* **规则:** 不管名字叫什么，只数它是第几行、第几列 (从 0 开始)。
* **语法:** `df.iloc[行号, 列号]`
* **特点:** 像 Python 列表切片一样，**不包含末尾**。

```python
# 场景: 我想要前 3 行，前 2 列的数据
print(df.iloc[0:3, 0:2]) 
# 0:3 代表取索引 0, 1, 2 (不含3)

```

> **🧠 避坑指南:** 除非你真的需要按位置循环，否则**强烈建议使用 `loc**`。代码的可读性更高，别人一眼就能看出你在取“城市”这一列，而不是莫名其妙的“第 1 列”。

---

## 4.5 数据的“过滤器”：布尔索引 (Boolean Indexing)

这是数据清洗中最强大的工具。它的逻辑是：先产生一个全是 True/False 的列表（掩码），然后把它贴到 DataFrame 上，True 留下，False 扔掉。

**任务：找出所有“温度 > 100”且“风力 < 4”的日子。**

```python
# 1. 定义条件
high_temp = df['温度'] > 100
low_wind = df['风力'] < 4

# 2. 组合筛选 (必须用 & 和 |，且条件要加括号)
result = df[high_temp & low_wind]

print(result)
# 输出: 
#             城市   温度   风力
# 2023-01-03  广州   120   2.0

```

---

## 4.6 数据的“维修站”：处理缺失值与数据转换

### 1. 处理 NaN (缺失值)

AI 模型（如线性回归、神经网络）通常无法处理空值，遇到就报错。

```python
# 检测: 哪里空了？
print(df.isnull().sum()) 
# 输出: 风力 1 (说明风力缺了1个)

# 方案 A: 暴力删除 (数据量大时用)
df.dropna(inplace=True)

# 方案 B: 填充 (数据量少时用)
# 比如用 0 填充，或者用平均风力填充
mean_wind = df['风力'].mean()
df['风力'].fillna(mean_wind, inplace=True)

```

### 2. 数据转换 (Apply)

**任务：把华氏度转换成摄氏度。**
公式：

`apply` 是 Pandas 中最灵活的函数，它允许你把一个函数应用到每一行或每一列上。

```python
def fahrenheit_to_celsius(f):
    return (f - 32) * 5 / 9

# 对 '温度' 这一列应用函数
df['温度(C)'] = df['温度'].apply(fahrenheit_to_celsius)

# 也可以用 Lambda 匿名函数写，更简洁
df['温度(C)'] = df['温度'].apply(lambda x: (x - 32) * 5/9)

```

---

## 4.7 数据的“透视表”：GroupBy 分组统计

这是数据分析的灵魂。我们经常需要问：**“每个城市的平均温度是多少？”**

这个过程被称为 **Split-Apply-Combine (拆分-应用-合并)**。

1. **Split:** 按“城市”把数据切分成几堆（北京堆、上海堆...）。
2. **Apply:** 对每一堆算平均值。
3. **Combine:** 把结果拼成一个新的表。

```python
# 语法: df.groupby('按谁分')['算谁'].怎么算()
city_stats = df.groupby('城市')['温度'].mean()

print(city_stats)
# 输出:
# 城市
# 上海    105.0
# 北京     97.5  <-- (100+95)/2
# 广州    120.0
# ...

```

---

## 本章小结：Pandas 技能树

恭喜你，你已经掌握了 Pandas 80% 的核心功能：

1. **IO:** 能读写数据 (`read_csv`, `DataFrame`).
2. **Inspect:** 能给数据体检 (`info`, `describe`).
3. **Select:** 能精准切割数据 (`loc`, `iloc`).
4. **Filter:** 能按条件筛选 (`df[condition]`).
5. **Process:** 能修补空值 (`fillna`) 和转换数据 (`apply`).
6. **Analyze:** 能分组统计 (`groupby`).

**下一章预告：**
数据已经就绪，我们终于要把 Pandas 处理好的数据喂给 **Matplotlib 和 Seaborn** 了。下一章，我们将学习如何把上面枯燥的表格变成一眼看穿趋势的折线图、直方图和热力图！